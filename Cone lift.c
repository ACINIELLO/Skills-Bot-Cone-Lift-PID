#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  touch,          sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           REDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           LEDrive,       tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           clift,         tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           clift2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           ARM,           tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port8,           RDrive,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LDrive,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*		NOTE:
Things marked with //FIX are things that are probably dependant on external
factors and need to change depending. Just make sure they're all right before
testing or stuff.
*/



//   __        __   __                          __          __        ___  __
//  / _` |    /  \ |__)  /\  |       \  /  /\  |__) |  /\  |__) |    |__  /__`
//  \__> |___ \__/ |__) /~~\ |___     \/  /~~\ |  \ | /~~\ |__) |___ |___ .__/
//

float kP_drive = 0.8;
float kP_drift = 2;
float kD = 0.085;
float kI = 1;
float kP=1;
const float kP_lift=1;
const float kI_lift=1;
const float kD_lift=1;
int counter=0;
int conesStacc=0;
float headingAngle = 0;

//Conversions
float inches_per_tile = 24.25;
float ticks_per_revolution = 392; //FIX This is for the high speed configuration only
float ticks_per_inch = ticks_per_revolution/(PI*4); //FIX 4" omni wheels
float ticks_per_tile = ticks_per_inch*inches_per_tile;

//moveStraight variables
float error;
float power;
float driftPower;
float targetTicks;
float prevError;
float gyroError;
float derivative;
float integral = 0;
float integral_active_zone = 4*ticks_per_inch; //FIX idk man arbitrary
float errorThreshold = 30; //errorThresholdInTicks=(ticks_per_inch)*(errorThresholdInInches) arbitrary
const int heightBetwCones; /* CALCULATE in ticks*/
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"



//   __   __   ___              ___  __
//  |__) |__) |__      /\  |  |  |  /  \ |\ |
//  |    |  \ |___    /~~\ \__/  |  \__/ | \|
//

void pre_auton()
{
	bool breakOut = true;
	slaveMotor(LDrive,LEDrive);
	slaveMotor(RDrive,REDrive);
	slaveMotor(clift2,clift);
	motor	[ARM]= 0; 
	/*
	while(breakOut){
	if(touch){
	breakOut = false;
	}
	}
	*/
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);
	SensorType[gyro] = sensorGyro;
	wait1Msec(2000);
	SensorValue[gyro] = 0;
}




//   __       ___            __   __
//  |  \  /\   |   /\  |    /  \ / _`
//  |__/ /~~\  |  /~~\ |___ \__/ \__>
//

task datalog(){
	while(1){
		datalogDataGroupStart();
		datalogAddValue( 0, error);
		datalogAddValue( 1, power);
		datalogAddValue( 2, SensorValue[gyro]);
		datalogAddValue( 3, integral);
		datalogAddValue( 4, motor[LEDrive]);
		datalogAddValue( 5, motor[REDrive]);
		datalogAddValue (6, motor[clift]);
		datalogAddValue(7,motor[ARM]);
		datalogDataGroupEnd();
		wait1Msec(25);
	}
}


//         __        ___     __  ___  __          __       ___
//   |\/| /  \ \  / |__     /__`  |  |__)  /\  | / _` |__|  |
//   |  | \__/  \/  |___    .__/  |  |  \ /~~\ | \__> |  |  |
//

void moveStraight(int direction, float tiles){
	targetTicks = tiles*ticks_per_tile;
	prevError = targetTicks;
	nMotorEncoder[LEDrive]=0;
	nMotorEncoder[REDrive]=0;
	error = targetTicks-((abs(nMotorEncoder[LEDrive])+abs(nMotorEncoder[REDrive]))/2);
	clearTimer(T1);
	while(time1[T1]<3000 && (abs(error)>errorThreshold)){
		error = targetTicks-((abs(nMotorEncoder[LEDrive])+abs(nMotorEncoder[REDrive]))/2);
		gyroError = (SensorValue[gyro]/10)-headingAngle; //Error in degrees

		integral = integral + error;
		if(error>integral_active_zone){
			integral = 0;
		}

		derivative = error - prevError;

		driftPower = gyroError * kP_drift;
		power = (kP_drive*error)+(kD*derivative)+(kI*integral);

		if(power>120){
			power = 120;
		}

		motor[LEDrive] = (direction*power)+driftPower; //FIX this assumes clockwise drift is negative
		motor[REDrive] = (direction*power)-driftPower;
		wait1Msec(25);
	}

	motor[LEDrive]=0;
	motor[REDrive]=0;
}
float coneLift (int conesStacc)  ///////* I got to fix the theory behind this with the for loop*////
{ int error;
	int prevError=0;
	int integral=0;
	int derivative;
	int power;
	int ticksPerCone;
	int i;
	int ticks=conesStacc*ticksPerCone+heightBetwCones;
	 for (i=0;i>=10;i++)/* assuming 10 cones*/

		{int ticks=0;
			counter+= counter;
			conesStacc = counter;
			ticks = conesStacc*ticksPerCone+heightBetwCones;
			return(ticks);}
			while(getMotorEncoder(clift)<ticks){
			error=ticks-getMotorEncoder(clift);
		integral=integral+error;
		if(error==0||(getMotorEncoder(clift2)>ticks)){
			integral=0;
		}
		if(error>1000){
			integral=0;
		}
		derivative=error-prevError;
		prevError=error;
		power=error*kP_lift+integral*kI_lift+derivative*kD_lift;
		motor[clift]=power;
		wait1Msec(15);
	}
	motor[clift]=0;
	counter=0;
return(0); }

void moveArm( int ticks) /* tune by testing encoder values for 90 deg and 0 deg */
{int error;
	int prevError=0;
	int integral=0;
	int derivative;
	int power;
	int ticksPerCone;
	int heightConstant;
	int i;
	const int Power = 100; 
	if ( ticks = 0 )/* 0 is in deg not in the wanting ticks ==> TEST*/
coneLift(conesStacc);
	if ( ticks != 90)/*90 is in terms of deg not ticks IT must be in ticks however==> TEST */
		motor[Arm] = 100;/*counterClockwise direction */
else 
	motor[Arm] = 0;
}
	


//            ___  __
//   /\  |  |  |  /  \
//  /~~\ \__/  |  \__/
//

task autonomous()
{
	startTask(datalog);
	moveStraight(1,1);
	wait1Msec(100);
	stopTask(datalog);
}



//        __   ___  __      __   __       ___  __   __
//  |  | /__` |__  |__)    /  ` /  \ |\ |  |  |__) /  \ |
//  \__/ .__/ |___ |  \    \__, \__/ | \|  |  |  \ \__/ |___
//

task usercontrol()///////* worry about user control afterwards *//////
{
	int driveThreshold = 20;
	slaveMotor(LDrive,LEDrive);
	slaveMotor(RDrive,REDrive);
	while (true)
	{
		while(1){
			if(abs(vexRT[Ch3])>driveThreshold){
				motor[LEDrive]=vexRT[Ch3];
				}	else {
				motor[LEDrive]=0;
			}
			if(abs(vexRT[Ch2])>driveThreshold){
				motor[REDrive]=vexRT[Ch2];
				}	else {
				motor[REDrive]=0;
			}
			if(vexRT[Btn6U]==1){
				//motor[lift]=127;
			}
			else if(vexRT[Btn6D]==1){
				//motor[lift]=-127;
			}
			else {
				//motor[lift]=0;
			}
		}
	}
}
